<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>GAP.jl · GAP.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">GAP.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>GAP.jl</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Macros"><span>Macros</span></a></li><li><a class="tocitem" href="#Conversions"><span>Conversions</span></a></li><li><a class="tocitem" href="#Convenience-adapters"><span>Convenience adapters</span></a></li><li><a class="tocitem" href="#Access-to-the-GAP-help-system"><span>Access to the GAP help system</span></a></li><li><a class="tocitem" href="#Managing-GAP-packages"><span>Managing GAP packages</span></a></li><li><a class="tocitem" href="#Other"><span>Other</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>GAP.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>GAP.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/oscar-system/GAP.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="GAP.jl"><a class="docs-heading-anchor" href="#GAP.jl">GAP.jl</a><a id="GAP.jl-1"></a><a class="docs-heading-anchor-permalink" href="#GAP.jl" title="Permalink"></a></h1><ul><li><a href="#GAP.jl">GAP.jl</a></li><ul><li><a href="#Introduction">Introduction</a></li><li><a href="#Types">Types</a></li><li><a href="#Macros">Macros</a></li><li><a href="#Conversions">Conversions</a></li><li><a href="#Convenience-adapters">Convenience adapters</a></li><li><a href="#Access-to-the-GAP-help-system">Access to the GAP help system</a></li><li><a href="#Managing-GAP-packages">Managing GAP packages</a></li><li><a href="#Other">Other</a></li><li><a href="#Index">Index</a></li></ul></ul><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>GAP.jl is a low level interface from Julia to <a href="https://www.gap-system.org">the computer algebra system GAP</a>. The term &quot;low level&quot; means that the aim is to give Julia access to all GAP objects, to let Julia call GAP functions, and to provide conversions of low level data (integers, Booleans, strings, arrays/lists, dictionaries/records) between the two systems.</p><p>In particular, it is <em>not</em> the aim of GAP.jl to provide Julia types for higher level GAP objects that represent algebraic structures, such as groups, rings, fields, etc., and mappings between such structures.</p><p>The connection between GAP and Julia is in fact bidirectional, that is, GAP can access all Julia objects, call Julia functions, and perform conversions of low level data. This direction will become interesting on the Julia side as soon as GAP packages provide functionality that is based on using Julia code from the GAP side.</p><p>The viewpoint of an interface from GAP to Julia is described in <a href="https://www.gap-system.org/Manuals/pkg/JuliaInterface/doc/chap0.html#X7D2C85EC87DD46E5">the manual of the GAP package JuliaInterface</a>.</p><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GAP.FFE" href="#GAP.FFE"><code>GAP.FFE</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FFE</code></pre><p>Wrap a pointer to a GAP FFE (&quot;finite field element&quot;) immediate object. This type is defined in the JuliaInterface C code.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x = GAP.evalstr( &quot;Z(3)&quot; )
GAP: Z(3)

julia&gt; typeof( x )
FFE
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/GAP.jl/blob/c76bfc1220eb474645efeb68d4f1e88d29a9bd09/src/types.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAP.GapObj" href="#GAP.GapObj"><code>GAP.GapObj</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GapObj</code></pre><p>This is the Julia type of all those GAP objects that are not &quot;immediate&quot; (booleans, small integers, FFEs).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; isa( GAP.evalstr( &quot;[ 1, 2 ]&quot; ), GapObj ) # a GAP list
true

julia&gt; isa( GAP.evalstr( &quot;rec()&quot; ), GapObj )    # a GAP record
true

julia&gt; isa( GAP.evalstr( &quot;(1,2,3)&quot; ), GapObj )  # a GAP permutation
true

julia&gt; isa( GAP.evalstr( &quot;2^64&quot; ), GapObj )     # a large GAP integer
true

julia&gt; typeof( GAP.evalstr( &quot;2^59&quot; ) )          # a small GAP integer
Int64

julia&gt; typeof( GAP.evalstr( &quot;Z(2)&quot; ) )          # a GAP FFE
FFE

julia&gt; typeof( GAP.evalstr( &quot;true&quot; ) )          # a boolean
Bool
</code></pre><p>Note that this is Julia&#39;s viewpoint on GAP objects. From the viewpoint of GAP, also the pointers to Julia objects are implemented as &quot;non-immediate GAP objects&quot;, but they appear as Julia objects to Julia, not &quot;doubly wrapped&quot;.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; GAP.evalstr( &quot;Julia.Base&quot; )
Base

julia&gt; typeof( GAP.evalstr( &quot;Julia.Base&quot; ) )        # native Julia object
Module
</code></pre><p>One can use <code>GapObj</code> as a constructor, in order to convert Julia objects to GAP objects. Such calls are delegated to <a href="#GAP.julia_to_gap"><code>julia_to_gap</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; GapObj(1//3)
GAP: 1/3

julia&gt; GapObj([1 2; 3 4])
GAP: [ [ 1, 2 ], [ 3, 4 ] ]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/GAP.jl/blob/c76bfc1220eb474645efeb68d4f1e88d29a9bd09/src/types.jl#L20-L79">source</a></section></article><h2 id="Macros"><a class="docs-heading-anchor" href="#Macros">Macros</a><a id="Macros-1"></a><a class="docs-heading-anchor-permalink" href="#Macros" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GAP.@gap" href="#GAP.@gap"><code>GAP.@gap</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@gap &lt;expr&gt;
@gap(&lt;expr&gt;)</code></pre><p>Execute &lt;expr&gt; directly in GAP, as if <code>GAP.evalstr(&quot;&lt;expr&gt;&quot;)</code> was called. This can be used for creating GAP literals directly from Julia.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; @gap [1,2,3]
GAP: [ 1, 2, 3 ]

julia&gt; @gap SymmetricGroup(3)
GAP: Sym( [ 1 .. 3 ] )

julia&gt; @gap(SymmetricGroup)(3)
GAP: Sym( [ 1 .. 3 ] )
</code></pre><p>Note that the last two examples have a slight syntactical, and therefore also a semantical difference. The first one executes the string <code>SymmetricGroup(3)</code> directly inside GAP. The second example returns the function <code>SymmetricGroup</code> via <code>@gap(SymmetricGroup)</code>, then calls that function with the argument <code>3</code>.</p><p>Due to Julia&#39;s way of handing over arguments into the code of macros, not all expressions representing valid GAP code can be processed. For example, the GAP syntax of permutations consisting of more than one cycle cause problems, as well as the GAP syntax of non-dense lists.</p><pre><code class="language-none">julia&gt; @gap (1,2,3)
GAP: (1,2,3)

julia&gt; @gap (1,2)(3,4)
ERROR: LoadError: Error thrown by GAP: Error, no method found! For debugging hints type ?Recovery from NoMethodFound
[...]

julia&gt; @gap [ 1,, 2 ]
ERROR: syntax: unexpected &quot;,&quot;
[...]
</code></pre><p>Note also that a string argument gets evaluated with <code>GAP.evalstr</code>.</p><pre><code class="language-julia-repl">julia&gt; @gap &quot;\&quot;abc\&quot;&quot;
GAP: &quot;abc&quot;

julia&gt; @gap &quot;[1,,2]&quot;
GAP: [ 1,, 2 ]

julia&gt; @gap &quot;(1,2)(3,4)&quot;
GAP: (1,2)(3,4)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/GAP.jl/blob/c76bfc1220eb474645efeb68d4f1e88d29a9bd09/src/macros.jl#L3-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAP.@g_str" href="#GAP.@g_str"><code>GAP.@g_str</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@g_str</code></pre><p>Create a GAP string by typing <code>g&quot;content&quot;</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; g&quot;foo&quot;
GAP: &quot;foo&quot;

julia&gt; g&quot;ab\ncd\&quot;ef\\gh&quot;   # special characters are handled as in GAP
GAP: &quot;ab\ncd\&quot;ef\\gh&quot;
</code></pre><p>Due to Julia&#39;s way of handing over arguments into the code of macros, not all strings representing valid GAP strings can be processed.</p><pre><code class="language-julia-repl">julia&gt; g&quot;\\&quot;
ERROR: LoadError: Error thrown by GAP: Syntax error: String must end with &quot; before end of file in stream:1
[...]
</code></pre><p>Conversely, there are valid arguments for the macro that are not valid Julia strings.</p><pre><code class="language-julia-repl">julia&gt; g&quot;\c&quot;
GAP: &quot;\c&quot;
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/GAP.jl/blob/c76bfc1220eb474645efeb68d4f1e88d29a9bd09/src/macros.jl#L84-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAP.@gapwrap" href="#GAP.@gapwrap"><code>GAP.@gapwrap</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@gapwrap</code></pre><p>When applied to a method definition that involves access to entries of <code>GAP.Globals</code>, this macro rewrites the code (using <code>@generated</code>) such that the relevant entries are cached at compile time, and need not be fetched again and again at runtime.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; @gapwrap isevenint(x) = GAP.Globals.IsEvenInt(x)::Bool;

julia&gt; isevenint(1)
false

julia&gt; isevenint(2)
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/GAP.jl/blob/c76bfc1220eb474645efeb68d4f1e88d29a9bd09/src/macros.jl#L126-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAP.@gapattribute" href="#GAP.@gapattribute"><code>GAP.@gapattribute</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@gapattribute</code></pre><p>This macro is intended to be applied to a method definition for a unary function called <code>attr</code>, say, where the argument has the type <code>T</code>, say, the code contains exactly one call of the form <code>GAP.Globals.Something(X)</code>, where <code>Something</code> is a GAP attribute such as <code>Centre</code> or <code>IsSolvableGroup</code>, and <code>attr</code> returns the corresponding attribute value for its argument.</p><p>The macro defines three functions <code>attr</code>, <code>hasattr</code>, and <code>setattr</code>, where <code>attr</code> takes an argument of type <code>T</code> and returns what the given method definition says, <code>hasattr</code> takes an argument of type <code>T</code> and returns the result of <code>GAP.Globals.HasSomething(X)</code> (which is either <code>true</code> or <code>false</code>), <code>setattr</code> takes an argument of type <code>T</code> and an object <code>obj</code> and calls <code>GAP.Globals.SetSomething(X, obj)</code>.</p><p>In order to avoid runtime access via <code>GAP.Globals.Something</code> etc., the same modifications are applied in the construction of the three functions that are applied by <a href="#GAP.@gapwrap"><code>@gapwrap</code></a>.</p><p>The variables that are created by the macro belong to the Julia module in whose scope the macro is called.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; @gapattribute isstrictlysortedlist(obj::GAP.GapObj) = GAP.Globals.IsSSortedList(obj)::Bool;

julia&gt; l = GAP.evalstr( &quot;[ 1, 3, 7 ]&quot; );

julia&gt; hasisstrictlysortedlist( l )
false

julia&gt; isstrictlysortedlist( l )
true

julia&gt; hasisstrictlysortedlist( l )
true

julia&gt; l = GAP.evalstr( &quot;[ 1, 3, 7 ]&quot; );

julia&gt; hasisstrictlysortedlist( l )
false

julia&gt; setisstrictlysortedlist( l, true )

julia&gt; hasisstrictlysortedlist( l )
true

julia&gt; isstrictlysortedlist( l )
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/GAP.jl/blob/c76bfc1220eb474645efeb68d4f1e88d29a9bd09/src/macros.jl#L191-L245">source</a></section></article><h2 id="Conversions"><a class="docs-heading-anchor" href="#Conversions">Conversions</a><a id="Conversions-1"></a><a class="docs-heading-anchor-permalink" href="#Conversions" title="Permalink"></a></h2><p>One of the main ideas of GAP.jl is that automatic conversions of Julia objects to GAP objects and vice versa shall be avoided whenever this is possible. For a few types of objects, such conversions are unavoidable, see <a href="#Automatic-GAP-to-Julia-and-Julia-to-GAP-Conversions">Automatic GAP-to-Julia and Julia-to-GAP Conversions</a>. In all other situations, the conversions between GAP objects and corresponding Julia objects can be performed using <a href="#GAP.gap_to_julia"><code>gap_to_julia</code></a> and <a href="#GAP.julia_to_gap"><code>julia_to_gap</code></a>, see <a href="#Explicit-GAP-to-Julia-and-Julia-to-GAP-Conversions">Explicit GAP-to-Julia and Julia-to-GAP Conversions</a>, respectively.</p><p>For convenience, also constructor methods are provided, for example <code>Vector{Int64}(obj)</code> can be used instead of <code>GAP.gap_to_julia(Vector{Int64}, obj)</code>, where <code>obj</code> is a GAP list of integers; see <a href="#Constructor-Methods-for-GAP-to-Julia-Conversions">Constructor Methods for GAP-to-Julia Conversions</a> for a description of these methods. For Julia-to-GAP conversions, one can use for example <code>GapObj(obj)</code>, where <code>obj</code> is a Julia object, see <a href="#GAP.GapObj"><code>GapObj</code></a>.</p><h3 id="Automatic-GAP-to-Julia-and-Julia-to-GAP-Conversions"><a class="docs-heading-anchor" href="#Automatic-GAP-to-Julia-and-Julia-to-GAP-Conversions">Automatic GAP-to-Julia and Julia-to-GAP Conversions</a><a id="Automatic-GAP-to-Julia-and-Julia-to-GAP-Conversions-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-GAP-to-Julia-and-Julia-to-GAP-Conversions" title="Permalink"></a></h3><p>When one calls a GAP function with Julia objects as arguments, or a Julia function with GAP objects as arguments, the arguments are in general not automatically converted to GAP objects or Julia objects, respectively. The exceptions are as follows.</p><ul><li><p>GAP&#39;s immediate integers (in the range -2^60 to 2^60-1) are automatically converted to Julia&#39;s <code>Int64</code> objects; Julia&#39;s <code>Int64</code> objects are automatically converted to GAP&#39;s immediate integers if they fit, and to GAP&#39;s large integers otherwise.</p></li><li><p>GAP&#39;s immediate finite field elements are automatically converted to Julia&#39;s <code>GAP.FFE</code> objects, and vice versa.</p></li><li><p>GAP&#39;s <code>true</code> and <code>false</code> are automatically converted to Julia&#39;s <code>true</code> and <code>false</code>, and vice versa.</p></li></ul><h3 id="Explicit-GAP-to-Julia-and-Julia-to-GAP-Conversions"><a class="docs-heading-anchor" href="#Explicit-GAP-to-Julia-and-Julia-to-GAP-Conversions">Explicit GAP-to-Julia and Julia-to-GAP Conversions</a><a id="Explicit-GAP-to-Julia-and-Julia-to-GAP-Conversions-1"></a><a class="docs-heading-anchor-permalink" href="#Explicit-GAP-to-Julia-and-Julia-to-GAP-Conversions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GAP.gap_to_julia" href="#GAP.gap_to_julia"><code>GAP.gap_to_julia</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">gap_to_julia(type, x, recursion_dict=nothing; recursive::Bool=true)</code></pre><p>Try to convert the object <code>x</code> to a Julia object of type <code>type</code>. If <code>x</code> is a <code>GAP.GapObj</code> then the conversion rules are defined in the manual of the GAP package JuliaInterface. If <code>x</code> is another <code>GAP.Obj</code> (for example a <code>Int64</code>) then the result is defined in Julia by <code>type</code>.</p><p>The parameter <code>recursion_dict</code> is meant to preserve the identity of converted subobjects and should never be given by the user.</p><p>For GAP lists and records, it makes sense to convert also the subobjects recursively, or to keep the subobjects as they are; the behaviour is controlled by <code>recursive</code>, which can be <code>true</code> or <code>false</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; GAP.gap_to_julia( GAP.evalstr( &quot;1/3&quot; ) )
1//3

julia&gt; GAP.gap_to_julia( GAP.evalstr( &quot;\&quot;abc\&quot;&quot; ) )
&quot;abc&quot;

julia&gt; val = GAP.evalstr( &quot;[ [ 1, 2 ], [ 3, 4 ] ]&quot; );

julia&gt; GAP.gap_to_julia( val )
2-element Vector{Any}:
 Any[1, 2]
 Any[3, 4]

julia&gt; GAP.gap_to_julia( val, recursive = false )
2-element Vector{Any}:
 GAP: [ 1, 2 ]
 GAP: [ 3, 4 ]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/GAP.jl/blob/c76bfc1220eb474645efeb68d4f1e88d29a9bd09/src/gap_to_julia.jl#L13-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAP.julia_to_gap" href="#GAP.julia_to_gap"><code>GAP.julia_to_gap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">julia_to_gap(input, recursion_dict = IdDict(); recursive::Bool = false)</code></pre><p>Convert a julia object <code>input</code> to an appropriate GAP object. If <code>recursive</code> is set to <code>true</code>, recursive conversions on arrays, tuples, and dictionaries is performed.</p><p>The input <code>recursion_dict</code> should never be set by the user, it is meant to keep egality of input data, by converting egal data to identical objects in GAP.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; GAP.julia_to_gap(1//3)
GAP: 1/3

julia&gt; GAP.julia_to_gap(&quot;abc&quot;)
GAP: &quot;abc&quot;

julia&gt; GAP.julia_to_gap([ [1, 2], [3, 4]])
GAP: [ &lt;Julia: [1, 2]&gt;, &lt;Julia: [3, 4]&gt; ]

julia&gt; GAP.julia_to_gap([ [1, 2], [3, 4]], recursive = true)
GAP: [ [ 1, 2 ], [ 3, 4 ] ]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/GAP.jl/blob/c76bfc1220eb474645efeb68d4f1e88d29a9bd09/src/julia_to_gap.jl#L2-L27">source</a></section></article><h3 id="Constructor-Methods-for-GAP-to-Julia-Conversions"><a class="docs-heading-anchor" href="#Constructor-Methods-for-GAP-to-Julia-Conversions">Constructor Methods for GAP-to-Julia Conversions</a><a id="Constructor-Methods-for-GAP-to-Julia-Conversions-1"></a><a class="docs-heading-anchor-permalink" href="#Constructor-Methods-for-GAP-to-Julia-Conversions" title="Permalink"></a></h3><p>(For Julia-to-GAP conversions, one can use <a href="#GAP.GapObj"><code>GapObj</code></a> as a constructor.)</p><article class="docstring"><header><a class="docstring-binding" id="Core.Int128" href="#Core.Int128"><code>Core.Int128</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Int128 &lt;: Signed</code></pre><p>128-bit signed integer type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ae8452a9e0b973991c30f27beb2201db1b0ea0d3/base/docs/basedocs.jl#L1715-L1719">source</a></section><section><div><pre><code class="language-none">Int128(obj::GapObj)</code></pre><p>Return the <code>Int128</code> converted from the <a href="https://www.gap-system.org/Manuals/doc/ref/chap14.html#X853DF11B80068ED5">GAP integer</a> <code>obj</code>. (Note that small GAP integers are represented by Julia <code>Int64</code> objects, in particular they are not <code>GapObj</code>s; their conversion is not handled by methods installed in GAP.jl.)</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; val = GAP.evalstr(&quot;2^80&quot;)
GAP: 1208925819614629174706176

julia&gt; Int128(val)
1208925819614629174706176
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/GAP.jl/blob/c76bfc1220eb474645efeb68d4f1e88d29a9bd09/src/constructors.jl#L42-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.GMP.BigInt" href="#Base.GMP.BigInt"><code>Base.GMP.BigInt</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BigInt &lt;: Signed</code></pre><p>Arbitrary precision integer type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ae8452a9e0b973991c30f27beb2201db1b0ea0d3/base/gmp.jl#L45-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Rational" href="#Base.Rational"><code>Base.Rational</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Rational{T&lt;:Integer} &lt;: Real</code></pre><p>Rational number type, with numerator and denominator of type <code>T</code>. Rationals are checked for overflow.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ae8452a9e0b973991c30f27beb2201db1b0ea0d3/base/rational.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.Float64" href="#Core.Float64"><code>Core.Float64</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Float64 &lt;: AbstractFloat</code></pre><p>64-bit floating point number type (IEEE 754 standard).</p><p>Binary format: 1 sign, 11 exponent, 52 fraction bits.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ae8452a9e0b973991c30f27beb2201db1b0ea0d3/base/docs/basedocs.jl#L1702-L1708">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.big" href="#Base.big"><code>Base.big</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">big(x)</code></pre><p>Convert a number to a maximum precision representation (typically <a href="#Base.GMP.BigInt"><code>BigInt</code></a> or <code>BigFloat</code>). See <a href="@ref BigFloat(::Any, rounding::RoundingMode)"><code>BigFloat</code></a> for information about some pitfalls with floating-point numbers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ae8452a9e0b973991c30f27beb2201db1b0ea0d3/base/gmp.jl#L459-L465">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.Char" href="#Core.Char"><code>Core.Char</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Char(c::Union{Number,AbstractChar})</code></pre><p><code>Char</code> is a 32-bit <a href="@ref"><code>AbstractChar</code></a> type that is the default representation of characters in Julia. <code>Char</code> is the type used for character literals like <code>&#39;x&#39;</code> and it is also the element type of <a href="#Core.String"><code>String</code></a>.</p><p>In order to losslessly represent arbitrary byte streams stored in a <code>String</code>, a <code>Char</code> value may store information that cannot be converted to a Unicode codepoint — converting such a <code>Char</code> to <code>UInt32</code> will throw an error. The <a href="@ref"><code>isvalid(c::Char)</code></a> function can be used to query whether <code>c</code> represents a valid Unicode character.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ae8452a9e0b973991c30f27beb2201db1b0ea0d3/base/char.jl#L33-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Cuchar" href="#Base.Cuchar"><code>Base.Cuchar</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Cuchar</code></pre><p>Equivalent to the native <code>unsigned char</code> c-type (<a href="@ref"><code>UInt8</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ae8452a9e0b973991c30f27beb2201db1b0ea0d3/base/ctypes.jl#L6-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.String" href="#Core.String"><code>Core.String</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">String(v::AbstractVector{UInt8})</code></pre><p>Create a new <code>String</code> object from a byte vector <code>v</code> containing UTF-8 encoded characters. If <code>v</code> is <code>Vector{UInt8}</code> it will be truncated to zero length and future modification of <code>v</code> cannot affect the contents of the resulting string. To avoid truncation of <code>Vector{UInt8}</code> data, use <code>String(copy(v))</code>; for other <code>AbstractVector</code> types, <code>String(v)</code> already makes a copy.</p><p>When possible, the memory of <code>v</code> will be used without copying when the <code>String</code> object is created. This is guaranteed to be the case for byte vectors returned by <a href="@ref"><code>take!</code></a> on a writable <a href="@ref"><code>IOBuffer</code></a> and by calls to <a href="@ref"><code>read(io, nb)</code></a>. This allows zero-copy conversion of I/O data to strings. In other cases, <code>Vector{UInt8}</code> data may be copied, but <code>v</code> is truncated anyway to guarantee consistent behavior.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ae8452a9e0b973991c30f27beb2201db1b0ea0d3/base/strings/string.jl#L36-L51">source</a></section><section><div><pre><code class="language-none">String(s::AbstractString)</code></pre><p>Convert a string to a contiguous byte array representation encoded as UTF-8 bytes. This representation is often appropriate for passing strings to C.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ae8452a9e0b973991c30f27beb2201db1b0ea0d3/base/strings/string.jl#L76-L81">source</a></section><section><div><pre><code class="language-none">String(obj::GapObj)</code></pre><p>Return the Julia string converted from the <a href="https://www.gap-system.org/Manuals/doc/ref/chap27.html#X7D28329B7EDB8F47">GAP string</a> <code>obj</code>. Note that <a href="https://www.gap-system.org/Manuals/doc/ref/chap27.html#X81FB5BE27903EC32">GAP&#39;s String function</a> can be applied to arbitrary GAP objects, similar to Julia&#39;s <code>string</code> function; this behaviour is not intended for this <code>String</code> constructor.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; val = GAP.evalstr(&quot;\&quot;abc\&quot;&quot;)
GAP: &quot;abc&quot;

julia&gt; String(val)
&quot;abc&quot;

julia&gt; val = GAP.evalstr(&quot;[]&quot;)
GAP: [  ]

julia&gt; String(val)   # an empty GAP list is a string
&quot;&quot;
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/GAP.jl/blob/c76bfc1220eb474645efeb68d4f1e88d29a9bd09/src/constructors.jl#L191-L215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.Symbol" href="#Core.Symbol"><code>Core.Symbol</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Symbol</code></pre><p>The type of object used to represent identifiers in parsed julia code (ASTs). Also often used as a name or label to identify an entity (e.g. as a dictionary key). <code>Symbol</code>s can be entered using the <code>:</code> quote operator:</p><pre><code class="language-julia-repl">julia&gt; :name
:name

julia&gt; typeof(:name)
Symbol

julia&gt; x = 42
42

julia&gt; eval(:x)
42</code></pre><p><code>Symbol</code>s can also be constructed from strings or other values by calling the constructor <code>Symbol(x...)</code>.</p><p><code>Symbol</code>s are immutable and should be compared using <code>===</code>. The implementation re-uses the same object for all <code>Symbol</code>s with the same name, so comparison tends to be efficient (it can just compare pointers).</p><p>Unlike strings, <code>Symbol</code>s are &quot;atomic&quot; or &quot;scalar&quot; entities that do not support iteration over characters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ae8452a9e0b973991c30f27beb2201db1b0ea0d3/base/docs/basedocs.jl#L1731-L1759">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.UnitRange" href="#Base.UnitRange"><code>Base.UnitRange</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">UnitRange{T&lt;:Real}</code></pre><p>A range parameterized by a <code>start</code> and <code>stop</code> of type <code>T</code>, filled with elements spaced by <code>1</code> from <code>start</code> until <code>stop</code> is exceeded. The syntax <code>a:b</code> with <code>a</code> and <code>b</code> both <code>Integer</code>s creates a <code>UnitRange</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; collect(UnitRange(2.3, 5.2))
3-element Vector{Float64}:
 2.3
 3.3
 4.3

julia&gt; typeof(1:10)
UnitRange{Int64}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ae8452a9e0b973991c30f27beb2201db1b0ea0d3/base/range.jl#L265-L283">source</a></section><section><div><pre><code class="language-none">UnitRange(obj::GapObj)</code></pre><p>Return the unit range converted from the <a href="https://www.gap-system.org/Manuals/doc/ref/chap21.html#X79596BDE7CAF8491">GAP range</a> <code>obj</code>, which has step width 1.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; val = GAP.evalstr(&quot;[ 1 .. 10 ]&quot;)
GAP: [ 1 .. 10 ]

julia&gt; UnitRange(val)
1:10

julia&gt; UnitRange{Int32}(val)
1:10
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/GAP.jl/blob/c76bfc1220eb474645efeb68d4f1e88d29a9bd09/src/constructors.jl#L443-L461">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.StepRange" href="#Base.StepRange"><code>Base.StepRange</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">StepRange{T, S} &lt;: OrdinalRange{T, S}</code></pre><p>Ranges with elements of type <code>T</code> with spacing of type <code>S</code>. The step between each element is constant, and the range is defined in terms of a <code>start</code> and <code>stop</code> of type <code>T</code> and a <code>step</code> of type <code>S</code>. Neither <code>T</code> nor <code>S</code> should be floating point types. The syntax <code>a:b:c</code> with <code>b &gt; 1</code> and <code>a</code>, <code>b</code>, and <code>c</code> all integers creates a <code>StepRange</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; collect(StepRange(1, Int8(2), 10))
5-element Vector{Int64}:
 1
 3
 5
 7
 9

julia&gt; typeof(StepRange(1, Int8(2), 10))
StepRange{Int64, Int8}

julia&gt; typeof(1:3:6)
StepRange{Int64, Int64}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ae8452a9e0b973991c30f27beb2201db1b0ea0d3/base/range.jl#L173-L198">source</a></section><section><div><pre><code class="language-none">StepRange(obj::GapObj)</code></pre><p>Return the step range converted from the <a href="https://www.gap-system.org/Manuals/doc/ref/chap21.html#X79596BDE7CAF8491">GAP range</a> <code>obj</code>, which may have arbitrary step width.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; val = GAP.evalstr(&quot;[ 1, 3 .. 11 ]&quot;)
GAP: [ 1, 3 .. 11 ]

julia&gt; StepRange(val)
1:2:11

julia&gt; r = StepRange{Int8,Int8}(val)
1:2:11

julia&gt; typeof(r)
StepRange{Int8, Int8}
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/GAP.jl/blob/c76bfc1220eb474645efeb68d4f1e88d29a9bd09/src/constructors.jl#L464-L485">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.Tuple" href="#Core.Tuple"><code>Core.Tuple</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Tuple{Types...}</code></pre><p>Tuples are an abstraction of the arguments of a function – without the function itself. The salient aspects of a function&#39;s arguments are their order and their types. Therefore a tuple type is similar to a parameterized immutable type where each parameter is the type of one field. Tuple types may have any number of parameters.</p><p>Tuple types are covariant in their parameters: <code>Tuple{Int}</code> is a subtype of <code>Tuple{Any}</code>. Therefore <code>Tuple{Any}</code> is considered an abstract type, and tuple types are only concrete if their parameters are. Tuples do not have field names; fields are only accessed by index.</p><p>See the manual section on <a href="@ref">Tuple Types</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ae8452a9e0b973991c30f27beb2201db1b0ea0d3/base/docs/basedocs.jl#L2366-L2378">source</a></section><section><div><pre><code class="language-none">Tuple{Types...}(obj::GapObj; recursive = true)</code></pre><p>Return the tuple converted from the <a href="https://www.gap-system.org/Manuals/doc/ref/chap21.html#X7B256AE5780F140A">GAP list</a> <code>obj</code>. The entries of the list are converted to the required types <code>Types...</code>, using <a href="#GAP.gap_to_julia"><code>gap_to_julia</code></a>. If <code>recursive</code> is <code>true</code> then the entries of the list are converted recursively, otherwise non-recursively.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; val = GAP.evalstr(&quot;[ 1, 5 ]&quot;)
GAP: [ 1, 5 ]

julia&gt; Tuple{Int64,Int64}(val)
(1, 5)

julia&gt; val = GAP.evalstr(&quot;[ [ 1 ], [ 2 ] ]&quot;)
GAP: [ [ 1 ], [ 2 ] ]

julia&gt; Tuple{Any,Any}(val)
(Any[1], Any[2])

julia&gt; Tuple{GapObj,GapObj}(val, recursive = false)
(GAP: [ 1 ], GAP: [ 2 ])
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/GAP.jl/blob/c76bfc1220eb474645efeb68d4f1e88d29a9bd09/src/constructors.jl#L411-L439">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.BitVector" href="#Base.BitVector"><code>Base.BitVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BitVector(nt::Tuple{Vararg{Bool}})</code></pre><p>Construct a <code>BitVector</code> from a tuple of <code>Bool</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; nt = (true, false, true, false)
(true, false, true, false)

julia&gt; BitVector(nt)
4-element BitVector:
 1
 0
 1
 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ae8452a9e0b973991c30f27beb2201db1b0ea0d3/base/bitarray.jl#L79-L95">source</a></section><section><div><pre><code class="language-none">BitVector(obj::GapObj)</code></pre><p>Return the bit vector converted from the <a href="https://www.gap-system.org/Manuals/doc/ref/chap22.html#X7AC531DD79B6938E">GAP list of booleans</a> <code>obj</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; val = GAP.evalstr(&quot;[ true, false, true ]&quot;)
GAP: [ true, false, true ]

julia&gt; BitVector(val)
3-element BitVector:
 1
 0
 1
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/GAP.jl/blob/c76bfc1220eb474645efeb68d4f1e88d29a9bd09/src/constructors.jl#L239-L257">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Vector" href="#Base.Vector"><code>Base.Vector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Vector{T} &lt;: AbstractVector{T}</code></pre><p>One-dimensional dense array with elements of type <code>T</code>, often used to represent a mathematical vector. Alias for <a href="@ref"><code>Array{T,1}</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ae8452a9e0b973991c30f27beb2201db1b0ea0d3/base/array.jl#L52-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Matrix" href="#Base.Matrix"><code>Base.Matrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Matrix{T} &lt;: AbstractMatrix{T}</code></pre><p>Two-dimensional dense array with elements of type <code>T</code>, often used to represent a mathematical matrix. Alias for <a href="@ref"><code>Array{T,2}</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ae8452a9e0b973991c30f27beb2201db1b0ea0d3/base/array.jl#L60-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Set" href="#Base.Set"><code>Base.Set</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Set([itr])</code></pre><p>Construct a <a href="#Base.Set"><code>Set</code></a> of the values generated by the given iterable object, or an empty set. Should be used instead of <a href="@ref"><code>BitSet</code></a> for sparse integer sets, or for sets of arbitrary objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ae8452a9e0b973991c30f27beb2201db1b0ea0d3/base/set.jl#L14-L20">source</a></section><section><div><pre><code class="language-none">Set{T}(obj::GapObj; recursive = true)</code></pre><p>Return the set converted from the <a href="https://www.gap-system.org/Manuals/doc/ref/chap21.html#X7B256AE5780F140A">GAP list</a> or <a href="https://www.gap-system.org/Manuals/doc/ref/chap30.html#X8050A8037984E5B6">GAP collection</a> <code>obj</code>. The elements of <code>obj</code> are converted to the required type <code>T</code>, using <a href="#GAP.gap_to_julia"><code>gap_to_julia</code></a>. If <code>recursive</code> is <code>true</code> then the elements are converted recursively, otherwise non-recursively.</p><p>This constructor method is intended for situations where the result involves only native Julia objects such as integers and strings. Dealing with results containing GAP objects will be inefficient.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; Set{Int}(GAP.evalstr(&quot;[ 1, 2, 1 ]&quot;))
Set{Int64} with 2 elements:
  2
  1

julia&gt; Set{Vector{Int}}(GAP.evalstr(&quot;[[1], [2], [1]]&quot;))
Set{Vector{Int64}} with 2 elements:
  [1]
  [2]

julia&gt; Set{String}(GAP.evalstr(&quot;[\&quot;a\&quot;, \&quot;b\&quot;]&quot;))
Set{String} with 2 elements:
  &quot;b&quot;
  &quot;a&quot;

julia&gt; Set{Any}(GAP.evalstr(&quot;[[1], [2], [1]]&quot;))
Set{Any} with 2 elements:
  Any[1]
  Any[2]
</code></pre><p>In the following examples, the order in which the Julia output is shown may vary.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; s = Set{Any}(GAP.evalstr(&quot;[[1], [2], [1]]&quot;), recursive = false);

julia&gt; s == Set{Any}([GAP.evalstr(&quot;[ 1 ]&quot;), GAP.evalstr(&quot;[ 2 ]&quot;)])
true

julia&gt; s = Set{Any}(GAP.evalstr(&quot;SymmetricGroup(2)&quot;), recursive = false);

julia&gt; s == Set{Any}([GAP.evalstr(&quot;()&quot;), GAP.evalstr(&quot;(1,2)&quot;)])
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/GAP.jl/blob/c76bfc1220eb474645efeb68d4f1e88d29a9bd09/src/constructors.jl#L349-L404">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Dict" href="#Base.Dict"><code>Base.Dict</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Dict([itr])</code></pre><p><code>Dict{K,V}()</code> constructs a hash table with keys of type <code>K</code> and values of type <code>V</code>. Keys are compared with <a href="@ref"><code>isequal</code></a> and hashed with <a href="@ref"><code>hash</code></a>.</p><p>Given a single iterable argument, constructs a <a href="#Base.Dict"><code>Dict</code></a> whose key-value pairs are taken from 2-tuples <code>(key,value)</code> generated by the argument.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Dict([(&quot;A&quot;, 1), (&quot;B&quot;, 2)])
Dict{String, Int64} with 2 entries:
  &quot;B&quot; =&gt; 2
  &quot;A&quot; =&gt; 1</code></pre><p>Alternatively, a sequence of pair arguments may be passed.</p><pre><code class="language-julia-repl">julia&gt; Dict(&quot;A&quot;=&gt;1, &quot;B&quot;=&gt;2)
Dict{String, Int64} with 2 entries:
  &quot;B&quot; =&gt; 2
  &quot;A&quot; =&gt; 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ae8452a9e0b973991c30f27beb2201db1b0ea0d3/base/dict.jl#L52-L77">source</a></section></article><h2 id="Convenience-adapters"><a class="docs-heading-anchor" href="#Convenience-adapters">Convenience adapters</a><a id="Convenience-adapters-1"></a><a class="docs-heading-anchor-permalink" href="#Convenience-adapters" title="Permalink"></a></h2><p>This section describes how one can manipulate GAP objects from the Julia side, using Julia syntax features.</p><article class="docstring"><header><a class="docstring-binding" id="GAP.Globals" href="#GAP.Globals"><code>GAP.Globals</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">Globals</code></pre><p>This is a global object that gives access to all global variables of the current GAP session via <code>getproperty</code> and <code>setproperty!</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; GAP.Globals.Size    # a global GAP function
GAP: &lt;Attribute &quot;Size&quot;&gt;

julia&gt; GAP.Globals.size    # there is no GAP variable with this name
ERROR: GAP variable size not bound
[...]

julia&gt; hasproperty( GAP.Globals, :size )
false

julia&gt; GAP.Globals.size = 17;

julia&gt; hasproperty( GAP.Globals, :size )
true

julia&gt; GAP.Globals.size
17

julia&gt; GAP.Globals.Julia   # Julia objects can be values of GAP variables
Main
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/GAP.jl/blob/c76bfc1220eb474645efeb68d4f1e88d29a9bd09/src/ccalls.jl#L359-L389">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAP.call_gap_func" href="#GAP.call_gap_func"><code>GAP.call_gap_func</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">call_gap_func(func::GapObj, args...; kwargs...)</code></pre><p>Call the GAP object <code>func</code> as a function, with arguments <code>args...</code> and global GAP options <code>kwargs...</code>, and return the result if there is one, and <code>nothing</code> otherwise.</p><p>There is no argument number checking here, all checks on the arguments are done by GAP itself.</p><p>For convenience, one can use the syntax <code>func(args...; kwargs...)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; GAP.Globals.Factors( 12 )
GAP: [ 2, 2, 3 ]

julia&gt; g = GAP.Globals.SylowSubgroup( GAP.Globals.SymmetricGroup( 6 ), 2 )
GAP: Group([ (1,2), (3,4), (1,3)(2,4), (5,6) ])

julia&gt; GAP.Globals.StructureDescription( g )
GAP: &quot;C2 x D8&quot;

julia&gt; g = GAP.Globals.SylowSubgroup( GAP.Globals.SymmetricGroup( 6 ), 2 );

julia&gt; GAP.Globals.StructureDescription( g, short = true )
GAP: &quot;2xD8&quot;
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/GAP.jl/blob/c76bfc1220eb474645efeb68d4f1e88d29a9bd09/src/ccalls.jl#L172-L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAP.evalstr" href="#GAP.evalstr"><code>GAP.evalstr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">evalstr(cmd::String)</code></pre><p>Let GAP execute the command(s) given by <code>cmd</code>; if an error occurs then report this error, otherwise if the last command has a result then return it, otherwise return <code>nothing</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; GAP.evalstr( &quot;1+2&quot; )
3

julia&gt; GAP.evalstr( &quot;x:= []&quot; )
GAP: [  ]

julia&gt; GAP.evalstr( &quot;y:= 2; Add( x, 1 )&quot; )

julia&gt; GAP.evalstr( &quot;x&quot; )
GAP: [ 1 ]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/GAP.jl/blob/c76bfc1220eb474645efeb68d4f1e88d29a9bd09/src/ccalls.jl#L48-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex" href="#Base.getindex"><code>Base.getindex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getindex(collection, key...)</code></pre><p>Retrieve the value(s) stored at the given key or index within a collection. The syntax <code>a[i,j,...]</code> is converted by the compiler to <code>getindex(a, i, j, ...)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = Dict(&quot;a&quot; =&gt; 1, &quot;b&quot; =&gt; 2)
Dict{String, Int64} with 2 entries:
  &quot;b&quot; =&gt; 2
  &quot;a&quot; =&gt; 1

julia&gt; getindex(A, &quot;a&quot;)
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ae8452a9e0b973991c30f27beb2201db1b0ea0d3/base/array.jl#L785-L801">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.setindex!" href="#Base.setindex!"><code>Base.setindex!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">setindex!(collection, value, key...)</code></pre><p>Store the given value at the given key or index within a collection. The syntax <code>a[i,j,...] = x</code> is converted by the compiler to <code>(setindex!(a, x, i, j, ...); x)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ae8452a9e0b973991c30f27beb2201db1b0ea0d3/base/array.jl#L835-L840">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getproperty" href="#Base.getproperty"><code>Base.getproperty</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getproperty(value, name::Symbol)</code></pre><p>The syntax <code>a.b</code> calls <code>getproperty(a, :b)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; struct MyType
           x
       end

julia&gt; function Base.getproperty(obj::MyType, sym::Symbol)
           if sym === :special
               return obj.x + 1
           else # fallback to getfield
               return getfield(obj, sym)
           end
       end

julia&gt; obj = MyType(1);

julia&gt; obj.special
2

julia&gt; obj.x
1</code></pre><p>See also <a href="@ref Base.propertynames"><code>propertynames</code></a> and <a href="#Base.setproperty!"><code>setproperty!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ae8452a9e0b973991c30f27beb2201db1b0ea0d3/base/docs/basedocs.jl#L2431-L2461">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.setproperty!" href="#Base.setproperty!"><code>Base.setproperty!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">setproperty!(value, name::Symbol, x)</code></pre><p>The syntax <code>a.b = c</code> calls <code>setproperty!(a, :b, c)</code>.</p><p>See also <a href="@ref Base.propertynames"><code>propertynames</code></a> and <a href="#Base.getproperty"><code>getproperty</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ae8452a9e0b973991c30f27beb2201db1b0ea0d3/base/docs/basedocs.jl#L2464-L2471">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.hasproperty" href="#Base.hasproperty"><code>Base.hasproperty</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">hasproperty(x, s::Symbol)</code></pre><p>Return a boolean indicating whether the object <code>x</code> has <code>s</code> as one of its own properties.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.2</header><div class="admonition-body"><p>This function requires at least Julia 1.2.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/ae8452a9e0b973991c30f27beb2201db1b0ea0d3/base/reflection.jl#L1583-L1590">source</a></section><section><div><pre><code class="language-none">hasproperty(x::GapObj, f::Symbol)
hasproperty(x::GapObj, f::Union{AbstractString,Int64})</code></pre><p>Return <code>true</code> if the GAP record <code>x</code> has a component that is described by <code>f</code>, and <code>false</code> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; r = GAP.evalstr( &quot;rec( a:= 1 )&quot; )
GAP: rec( a := 1 )

julia&gt; hasproperty( r, :a )
true

julia&gt; hasproperty( r, :b )
false

julia&gt; r.b = 2
2

julia&gt; hasproperty( r, :b )
true

julia&gt; r
GAP: rec( a := 1, b := 2 )
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/GAP.jl/blob/c76bfc1220eb474645efeb68d4f1e88d29a9bd09/src/adapter.jl#L200-L228">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAP.wrap_rng" href="#GAP.wrap_rng"><code>GAP.wrap_rng</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">wrap_rng(rng::Random.AbstractRNG)</code></pre><p>Return a GAP object in the filter <code>IsRandomSource</code> that uses <code>rng</code> in calls to GAP&#39;s <code>Random</code> function. The idea is that GAP&#39;s <code>Random</code> methods for high level objects will just hand over the given random source to subfunctions until <code>Random</code> gets called for a list or the bounds of a range, and then <code>Base.rand</code> gets called with <code>rng</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; rng1 = Random.default_rng();

julia&gt; rng2 = copy(rng1);

julia&gt; rng1 == rng2
true

julia&gt; rng1 === rng2
false

julia&gt; gap_rng1 = GAP.wrap_rng(rng1)
GAP: &lt;RandomSource in IsRandomSourceJulia&gt;

julia&gt; gap_rng2 = GAP.wrap_rng(rng2)
GAP: &lt;RandomSource in IsRandomSourceJulia&gt;

julia&gt; res1 = GAP.Globals.Random(gap_rng1, 1, 10);

julia&gt; rng1 == rng2   # the two rngs have diverged
false

julia&gt; res1 == GAP.Globals.Random(gap_rng2, GAP.GapObj(1:10))
true

julia&gt; rng1 == rng2   # now the two rngs are again in sync
true

julia&gt; g = GAP.Globals.SymmetricGroup(10);

julia&gt; p = GAP.Globals.Random(gap_rng1, g);

julia&gt; p in g
true

julia&gt; GAP.Globals.Random(gap_rng1, GAP.Globals.GF(2)^10)
GAP: &lt;a GF2 vector of length 10&gt;
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/GAP.jl/blob/c76bfc1220eb474645efeb68d4f1e88d29a9bd09/src/adapter.jl#L405-L455">source</a></section></article><p>For the following Julia functions, methods are provided that deal with the case that the arguments are GAP objects; they delegate to the corresponding GAP operations.</p><table><tr><th style="text-align: right">Julia</th><th style="text-align: right">GAP</th></tr><tr><td style="text-align: right"><code>length</code></td><td style="text-align: right"><code>Length</code></td></tr><tr><td style="text-align: right"><code>in</code></td><td style="text-align: right"><code>\in</code></td></tr><tr><td style="text-align: right"><code>zero</code></td><td style="text-align: right"><code>ZERO</code></td></tr><tr><td style="text-align: right"><code>one</code></td><td style="text-align: right"><code>ONE</code></td></tr><tr><td style="text-align: right"><code>-</code> (unary)</td><td style="text-align: right"><code>AINV</code></td></tr><tr><td style="text-align: right"><code>+</code></td><td style="text-align: right"><code>SUM</code></td></tr><tr><td style="text-align: right"><code>-</code> (binary)</td><td style="text-align: right"><code>DIFF</code></td></tr><tr><td style="text-align: right"><code>*</code></td><td style="text-align: right"><code>PROD</code></td></tr><tr><td style="text-align: right"><code>/</code></td><td style="text-align: right"><code>QUO</code></td></tr><tr><td style="text-align: right"><code>\</code></td><td style="text-align: right"><code>LQUO</code></td></tr><tr><td style="text-align: right"><code>^</code></td><td style="text-align: right"><code>POW</code></td></tr><tr><td style="text-align: right"><code>mod</code></td><td style="text-align: right"><code>MOD</code></td></tr><tr><td style="text-align: right"><code>&lt;</code></td><td style="text-align: right"><code>LT</code></td></tr><tr><td style="text-align: right"><code>==</code></td><td style="text-align: right"><code>EQ</code></td></tr></table><pre><code class="language-julia-repl">julia&gt; l = GAP.julia_to_gap( [ 1, 3, 7, 15 ] )
GAP: [ 1, 3, 7, 15 ]

julia&gt; m = GAP.julia_to_gap( [ 1 2; 3 4 ] )
GAP: [ [ 1, 2 ], [ 3, 4 ] ]

julia&gt; length( l )
4

julia&gt; length( m )  # different from Julia&#39;s behaviour
2

julia&gt; 1 in l
true

julia&gt; 2 in l
false

julia&gt; zero( l )
GAP: [ 0, 0, 0, 0 ]

julia&gt; one( m )
GAP: [ [ 1, 0 ], [ 0, 1 ] ]

julia&gt; - l
GAP: [ -1, -3, -7, -15 ]

julia&gt; l + 1
GAP: [ 2, 4, 8, 16 ]

julia&gt; l + l
GAP: [ 2, 6, 14, 30 ]

julia&gt; m + m
GAP: [ [ 2, 4 ], [ 6, 8 ] ]

julia&gt; 1 - m
GAP: [ [ 0, -1 ], [ -2, -3 ] ]

julia&gt; l * l
284

julia&gt; l * m
GAP: [ 10, 14 ]

julia&gt; m * m
GAP: [ [ 7, 10 ], [ 15, 22 ] ]

julia&gt; 1 / m
GAP: [ [ -2, 1 ], [ 3/2, -1/2 ] ]

julia&gt; m / 2
GAP: [ [ 1/2, 1 ], [ 3/2, 2 ] ]

julia&gt; 2 \ m
GAP: [ [ 1/2, 1 ], [ 3/2, 2 ] ]

julia&gt; m ^ 2
GAP: [ [ 7, 10 ], [ 15, 22 ] ]

julia&gt; m ^ -1
GAP: [ [ -2, 1 ], [ 3/2, -1/2 ] ]

julia&gt; mod( l, 3 )
GAP: [ 1, 0, 1, 0 ]

julia&gt; m &lt; 2 * m
true

julia&gt; m^2 - 5 * m == 2 * one( m )
true
</code></pre><h2 id="Access-to-the-GAP-help-system"><a class="docs-heading-anchor" href="#Access-to-the-GAP-help-system">Access to the GAP help system</a><a id="Access-to-the-GAP-help-system-1"></a><a class="docs-heading-anchor-permalink" href="#Access-to-the-GAP-help-system" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GAP.show_gap_help" href="#GAP.show_gap_help"><code>GAP.show_gap_help</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">show_gap_help(topic::String, onlyexact::Bool = false)</code></pre><p>Print the information from the GAP help system about <code>topic</code> to the screen. If <code>onlyexact</code> is <code>true</code> then only exact matches are shown, otherwise all matches. For example, <code>GAP.show_gap_help(&quot;Size&quot;)</code> shows also documentation for <code>SizeScreen</code> and <code>SizesPerfectGroups</code>, whereas <code>GAP.show_gap_help(&quot;Size&quot;, true)</code> shows only documentation for <code>Size</code>.</p><p>For the variant showing all matches, one can also enter <code>?GAP.Globals.Size</code> at the Julia prompt instead of calling <code>show_gap_help</code>.</p><p><strong>Examples</strong></p><pre><code class="language-none">julia&gt; GAP.show_gap_help( &quot;Size&quot; )
[...]  # more than 50 entries from GAP manuals

help?&gt; GAP.Globals.Size
[...]  # the same

julia&gt; GAP.show_gap_help( &quot;Size&quot;, true )
[...]  # about 15 entries from GAP manuals
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/GAP.jl/blob/c76bfc1220eb474645efeb68d4f1e88d29a9bd09/src/help.jl#L40-L67">source</a></section></article><h2 id="Managing-GAP-packages"><a class="docs-heading-anchor" href="#Managing-GAP-packages">Managing GAP packages</a><a id="Managing-GAP-packages-1"></a><a class="docs-heading-anchor-permalink" href="#Managing-GAP-packages" title="Permalink"></a></h2><p>The following functions allow one to load/install/update/remove GAP packages.</p><article class="docstring"><header><a class="docstring-binding" id="GAP.Packages.load" href="#GAP.Packages.load"><code>GAP.Packages.load</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">load(spec::String, version::String = &quot;&quot;; install = false)</code></pre><p>Try to load the newest installed version of the GAP package with name <code>spec</code>. Return <code>true</code> if this is successful, and <code>false</code> otherwise.</p><p>The function calls <a href="https://www.gap-system.org/Manuals/doc/ref/chap76.html#X79B373A77B29D1F5">GAP&#39;s <code>LoadPackage</code> function</a>; the package banner is not printed.</p><p>If <code>install</code> is set to <code>true</code> and the required GAP package is not yet installed then <a href="#GAP.Packages.install"><code>install</code></a> is called first, in order to install the newest released version of the package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/GAP.jl/blob/c76bfc1220eb474645efeb68d4f1e88d29a9bd09/src/packages.jl#L23-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAP.Packages.install" href="#GAP.Packages.install"><code>GAP.Packages.install</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">install(spec::String; interactive::Bool = true, quiet::Bool = false)</code></pre><p>Download and install the newest released version of the GAP package given by <code>spec</code> in the <code>pkg</code> subdirectory of GAP&#39;s build directory (variable <code>GAP.GAPROOT</code>). Return <code>true</code> if the installation is successful or if the package was already installed, and <code>false</code> otherwise.</p><p><code>spec</code> can be either the name of a package or the URL of an archive or repository containing a package, or the URL of a <code>PackageInfo.g</code> file.</p><p>The function uses <a href="https://www.gap-system.org/Manuals/gaproot/v1.6/pkg/PackageManager-1.1/doc/chap2.html#X81A6FF1B81D004BA">the function <code>InstallPackage</code> from GAP&#39;s package <code>PackageManager</code></a>. The info messages shown by  this function can be suppressed by entering <code>true</code> as the value of <code>quiet</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/GAP.jl/blob/c76bfc1220eb474645efeb68d4f1e88d29a9bd09/src/packages.jl#L56-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAP.Packages.update" href="#GAP.Packages.update"><code>GAP.Packages.update</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">update(spec::String; quiet::Bool = false)</code></pre><p>Update the GAP package given by <code>spec</code> that is installed in the <code>pkg</code> subdirectory of GAP&#39;s build directory (variable <code>GAP.GAPROOT</code>), to the latest version. Return <code>true</code> if a newer version was installed successfully, or if no newer version is available, and <code>false</code> otherwise.</p><p><code>spec</code> can be either the name of a package or the URL of an archive or repository containing a package, or the URL of a <code>PackageInfo.g</code> file.</p><p>The function uses <a href="https://www.gap-system.org/Manuals/gaproot/v1.6/pkg/PackageManager-1.1/doc/chap2.html#X7A3A079387DAA79A">the function <code>UpdatePackage</code> from GAP&#39;s package <code>PackageManager</code></a>. The info messages shown by  this function can be suppressed by entering <code>true</code> as the value of <code>quiet</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/GAP.jl/blob/c76bfc1220eb474645efeb68d4f1e88d29a9bd09/src/packages.jl#L89-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAP.Packages.remove" href="#GAP.Packages.remove"><code>GAP.Packages.remove</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">remove(spec::String; quiet::Bool = false)</code></pre><p>Remove the GAP package with name <code>spec</code> that is installed in the <code>pkg</code> subdirectory of GAP&#39;s build directory (variable <code>GAP.GAPROOT</code>). Return <code>true</code> if the removal was successful, and <code>false</code> otherwise.</p><p>The function uses <a href="https://www.gap-system.org/Manuals/gaproot/v1.6/pkg/PackageManager-1.1/doc/chap2.html#X8011AC33841B515C">the function <code>RemovePackage</code> from GAP&#39;s package <code>PackageManager</code></a>. The info messages shown by  this function can be suppressed by entering <code>true</code> as the value of <code>quiet</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/GAP.jl/blob/c76bfc1220eb474645efeb68d4f1e88d29a9bd09/src/packages.jl#L125-L136">source</a></section></article><h2 id="Other"><a class="docs-heading-anchor" href="#Other">Other</a><a id="Other-1"></a><a class="docs-heading-anchor-permalink" href="#Other" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GAP.prompt" href="#GAP.prompt"><code>GAP.prompt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">prompt()</code></pre><p>Start a GAP prompt where you can enter GAP commands as in a regular GAP session. This prompt can be left as any GAP prompt by either entering <code>quit;</code> or pressing ctrl-D, which returns to the Julia prompt.</p><p>This GAP prompt allows to quickly switch between writing Julia and GAP code in a session where all data is shared.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/GAP.jl/blob/c76bfc1220eb474645efeb68d4f1e88d29a9bd09/src/prompt.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GAP.create_gap_sh" href="#GAP.create_gap_sh"><code>GAP.create_gap_sh</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">create_gap_sh(dstdir::String)</code></pre><p>Given a directory path, create three files in that directory:</p><ul><li>a shell script named <code>gap.sh</code> which acts like the <code>gap.sh</code> shipped with a regular GAP installation, but which behind the scenes launches GAP via Julia.</li><li>two TOML files, <code>Manifest.toml</code> and <code>Project.toml</code>, which are required by <code>gap.sh</code> to function (they record the precise versions of GAP.jl and other Julia packages involved)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/oscar-system/GAP.jl/blob/c76bfc1220eb474645efeb68d4f1e88d29a9bd09/src/setup.jl#L262-L271">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#GAP.Globals"><code>GAP.Globals</code></a></li><li><a href="#Base.BitVector"><code>Base.BitVector</code></a></li><li><a href="#Base.Cuchar"><code>Base.Cuchar</code></a></li><li><a href="#Base.Dict"><code>Base.Dict</code></a></li><li><a href="#Base.GMP.BigInt"><code>Base.GMP.BigInt</code></a></li><li><a href="#Base.Matrix"><code>Base.Matrix</code></a></li><li><a href="#Base.Rational"><code>Base.Rational</code></a></li><li><a href="#Base.Set"><code>Base.Set</code></a></li><li><a href="#Base.StepRange"><code>Base.StepRange</code></a></li><li><a href="#Base.UnitRange"><code>Base.UnitRange</code></a></li><li><a href="#Base.Vector"><code>Base.Vector</code></a></li><li><a href="#Core.Char"><code>Core.Char</code></a></li><li><a href="#Core.Float64"><code>Core.Float64</code></a></li><li><a href="#Core.Int128"><code>Core.Int128</code></a></li><li><a href="#Core.String"><code>Core.String</code></a></li><li><a href="#Core.Symbol"><code>Core.Symbol</code></a></li><li><a href="#Core.Tuple"><code>Core.Tuple</code></a></li><li><a href="#GAP.FFE"><code>GAP.FFE</code></a></li><li><a href="#GAP.GapObj"><code>GAP.GapObj</code></a></li><li><a href="#Base.big"><code>Base.big</code></a></li><li><a href="#Base.getindex"><code>Base.getindex</code></a></li><li><a href="#Base.getproperty"><code>Base.getproperty</code></a></li><li><a href="#Base.hasproperty"><code>Base.hasproperty</code></a></li><li><a href="#Base.setindex!"><code>Base.setindex!</code></a></li><li><a href="#Base.setproperty!"><code>Base.setproperty!</code></a></li><li><a href="#GAP.Packages.install"><code>GAP.Packages.install</code></a></li><li><a href="#GAP.Packages.load"><code>GAP.Packages.load</code></a></li><li><a href="#GAP.Packages.remove"><code>GAP.Packages.remove</code></a></li><li><a href="#GAP.Packages.update"><code>GAP.Packages.update</code></a></li><li><a href="#GAP.call_gap_func"><code>GAP.call_gap_func</code></a></li><li><a href="#GAP.create_gap_sh"><code>GAP.create_gap_sh</code></a></li><li><a href="#GAP.evalstr"><code>GAP.evalstr</code></a></li><li><a href="#GAP.gap_to_julia"><code>GAP.gap_to_julia</code></a></li><li><a href="#GAP.julia_to_gap"><code>GAP.julia_to_gap</code></a></li><li><a href="#GAP.prompt"><code>GAP.prompt</code></a></li><li><a href="#GAP.show_gap_help"><code>GAP.show_gap_help</code></a></li><li><a href="#GAP.wrap_rng"><code>GAP.wrap_rng</code></a></li><li><a href="#GAP.@g_str"><code>GAP.@g_str</code></a></li><li><a href="#GAP.@gap"><code>GAP.@gap</code></a></li><li><a href="#GAP.@gapattribute"><code>GAP.@gapattribute</code></a></li><li><a href="#GAP.@gapwrap"><code>GAP.@gapwrap</code></a></li></ul></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 7 October 2021 12:25">Thursday 7 October 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
