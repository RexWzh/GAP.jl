var documenterSearchIndex = {"docs":
[{"location":"#GAP.jl","page":"GAP.jl","title":"GAP.jl","text":"","category":"section"},{"location":"","page":"GAP.jl","title":"GAP.jl","text":"","category":"page"},{"location":"","page":"GAP.jl","title":"GAP.jl","text":"CurrentModule = GAP\nDocTestSetup = quote\n  using GAP\nend","category":"page"},{"location":"#Introduction","page":"GAP.jl","title":"Introduction","text":"","category":"section"},{"location":"","page":"GAP.jl","title":"GAP.jl","text":"GAP.jl is a low level interface from Julia to the computer algebra system GAP. The term \"low level\" means that the aim is to give Julia access to all GAP objects, to let Julia call GAP functions, and to provide conversions of low level data (integers, Booleans, strings, arrays/lists, dictionaries/records) between the two systems.","category":"page"},{"location":"","page":"GAP.jl","title":"GAP.jl","text":"In particular, it is not the aim of GAP.jl to provide Julia types for higher level GAP objects that represent algebraic structures, such as groups, rings, fields, etc., and mappings between such structures.","category":"page"},{"location":"","page":"GAP.jl","title":"GAP.jl","text":"The connection between GAP and Julia is in fact bidirectional, that is, GAP can access all Julia objects, call Julia functions, and perform conversions of low level data. This direction will become interesting on the Julia side as soon as GAP packages provide functionality that is based on using Julia code from the GAP side.","category":"page"},{"location":"","page":"GAP.jl","title":"GAP.jl","text":"The viewpoint of an interface from GAP to Julia is described in the manual of the GAP package JuliaInterface.","category":"page"},{"location":"#Types","page":"GAP.jl","title":"Types","text":"","category":"section"},{"location":"","page":"GAP.jl","title":"GAP.jl","text":"FFE\nGapObj","category":"page"},{"location":"#GAP.FFE","page":"GAP.jl","title":"GAP.FFE","text":"FFE\n\nWrap a pointer to a GAP FFE (\"finite field element\") immediate object. This type is defined in the JuliaInterface C code.\n\nExamples\n\njulia> x = GAP.evalstr( \"Z(3)\" )\nGAP: Z(3)\n\njulia> typeof( x )\nFFE\n\n\n\n\n\n\n","category":"type"},{"location":"#GAP.GapObj","page":"GAP.jl","title":"GAP.GapObj","text":"GapObj\n\nThis is the Julia type of all those GAP objects that are not \"immediate\" (booleans, small integers, FFEs).\n\nExamples\n\njulia> isa( GAP.evalstr( \"[ 1, 2 ]\" ), GapObj ) # a GAP list\ntrue\n\njulia> isa( GAP.evalstr( \"rec()\" ), GapObj )    # a GAP record\ntrue\n\njulia> isa( GAP.evalstr( \"(1,2,3)\" ), GapObj )  # a GAP permutation\ntrue\n\njulia> isa( GAP.evalstr( \"2^64\" ), GapObj )     # a large GAP integer\ntrue\n\njulia> typeof( GAP.evalstr( \"2^59\" ) )          # a small GAP integer\nInt64\n\njulia> typeof( GAP.evalstr( \"Z(2)\" ) )          # a GAP FFE\nFFE\n\njulia> typeof( GAP.evalstr( \"true\" ) )          # a boolean\nBool\n\n\nNote that this is Julia's viewpoint on GAP objects. From the viewpoint of GAP, also the pointers to Julia objects are implemented as \"non-immediate GAP objects\", but they appear as Julia objects to Julia, not \"doubly wrapped\".\n\nExamples\n\njulia> GAP.evalstr( \"Julia.Base\" )\nBase\n\njulia> typeof( GAP.evalstr( \"Julia.Base\" ) )        # native Julia object\nModule\n\n\nOne can use GapObj as a constructor, in order to convert Julia objects to GAP objects. Such calls are delegated to julia_to_gap.\n\nExamples\n\njulia> GapObj(1//3)\nGAP: 1/3\n\njulia> GapObj([1 2; 3 4])\nGAP: [ [ 1, 2 ], [ 3, 4 ] ]\n\n\n\n\n\n\n","category":"type"},{"location":"#Macros","page":"GAP.jl","title":"Macros","text":"","category":"section"},{"location":"","page":"GAP.jl","title":"GAP.jl","text":"@gap\n@g_str\n@gapwrap\n@gapattribute","category":"page"},{"location":"#GAP.@gap","page":"GAP.jl","title":"GAP.@gap","text":"@gap <expr>\n@gap(<expr>)\n\nExecute <expr> directly in GAP, as if GAP.evalstr(\"<expr>\") was called. This can be used for creating GAP literals directly from Julia.\n\nExamples\n\njulia> @gap [1,2,3]\nGAP: [ 1, 2, 3 ]\n\njulia> @gap SymmetricGroup(3)\nGAP: Sym( [ 1 .. 3 ] )\n\njulia> @gap(SymmetricGroup)(3)\nGAP: Sym( [ 1 .. 3 ] )\n\n\nNote that the last two examples have a slight syntactical, and therefore also a semantical difference. The first one executes the string SymmetricGroup(3) directly inside GAP. The second example returns the function SymmetricGroup via @gap(SymmetricGroup), then calls that function with the argument 3.\n\nDue to Julia's way of handing over arguments into the code of macros, not all expressions representing valid GAP code can be processed. For example, the GAP syntax of permutations consisting of more than one cycle cause problems, as well as the GAP syntax of non-dense lists.\n\njulia> @gap (1,2,3)\nGAP: (1,2,3)\n\njulia> @gap (1,2)(3,4)\nERROR: LoadError: Error thrown by GAP: Error, no method found! For debugging hints type ?Recovery from NoMethodFound\n[...]\n\njulia> @gap [ 1,, 2 ]\nERROR: syntax: unexpected \",\"\n[...]\n\n\nNote also that a string argument gets evaluated with GAP.evalstr.\n\njulia> @gap \"\\\"abc\\\"\"\nGAP: \"abc\"\n\njulia> @gap \"[1,,2]\"\nGAP: [ 1,, 2 ]\n\njulia> @gap \"(1,2)(3,4)\"\nGAP: (1,2)(3,4)\n\n\n\n\n\n\n","category":"macro"},{"location":"#GAP.@g_str","page":"GAP.jl","title":"GAP.@g_str","text":"@g_str\n\nCreate a GAP string by typing g\"content\".\n\nExamples\n\njulia> g\"foo\"\nGAP: \"foo\"\n\njulia> g\"ab\\ncd\\\"ef\\\\gh\"   # special characters are handled as in GAP\nGAP: \"ab\\ncd\\\"ef\\\\gh\"\n\n\nDue to Julia's way of handing over arguments into the code of macros, not all strings representing valid GAP strings can be processed.\n\njulia> g\"\\\\\"\nERROR: LoadError: Error thrown by GAP: Syntax error: String must end with \" before end of file in stream:1\n[...]\n\n\nConversely, there are valid arguments for the macro that are not valid Julia strings.\n\njulia> g\"\\c\"\nGAP: \"\\c\"\n\n\n\n\n\n\n","category":"macro"},{"location":"#GAP.@gapwrap","page":"GAP.jl","title":"GAP.@gapwrap","text":"@gapwrap\n\nWhen applied to a method definition that involves access to entries of GAP.Globals, this macro rewrites the code (using @generated) such that the relevant entries are cached at compile time, and need not be fetched again and again at runtime.\n\nExamples\n\njulia> @gapwrap isevenint(x) = GAP.Globals.IsEvenInt(x)::Bool;\n\njulia> isevenint(1)\nfalse\n\njulia> isevenint(2)\ntrue\n\n\n\n\n\n\n","category":"macro"},{"location":"#GAP.@gapattribute","page":"GAP.jl","title":"GAP.@gapattribute","text":"macro gapattribute\n\nThis macro is intended to be applied to a method definition for a unary function called attr, say, where the argument has the type T, say, the code contains exactly one call of the form GAP.Globals.Something(X), where Something is a GAP attribute such as Centre or IsSolvableGroup, and attr returns the corresponding attribute value for its argument.\n\nThe macro defines three functions attr, hasattr, and setattr, where attr takes an argument of type T and returns what the given method definition says, hasattr takes an argument of type T and returns the result of GAP.Globals.HasSomething(X) (which is either true or false), setattr takes an argument of type T and an object obj and calls GAP.Globals.SetSomething(X, obj).\n\nIn order to avoid runtime access via GAP.Globals.Something etc., the same modifications are applied in the construction of the three functions that are applied by @gapwrap.\n\nThe variables that are created by the macro belong to the Julia module in whose scope the macro is called.\n\nExamples\n\njulia> @gapattribute isstrictlysortedlist(obj::GAP.GapObj) = GAP.Globals.IsSSortedList(obj)\n\njulia> l = GAP.evalstr( \"[ 1, 3, 7 ]\" );\n\njulia> hasisstrictlysortedlist( l )\nfalse\n\njulia> isstrictlysortedlist( l )\ntrue\n\njulia> hasisstrictlysortedlist( l )\ntrue\n\njulia> l = GAP.evalstr( \"[ 1, 3, 7 ]\" );\n\njulia> hasisstrictlysortedlist( l )\nfalse\n\njulia> setisstrictlysortedlist( l, true )\n\njulia> hasisstrictlysortedlist( l )\ntrue\n\njulia> isstrictlysortedlist( l )\ntrue\n\n\n\n\n\n\n","category":"macro"},{"location":"#Conversions","page":"GAP.jl","title":"Conversions","text":"","category":"section"},{"location":"","page":"GAP.jl","title":"GAP.jl","text":"One of the main ideas of GAP.jl is that automatic conversions of Julia objects to GAP objects and vice versa shall be avoided whenever this is possible. For a few types of objects, such conversions are unavoidable, see Automatic GAP-to-Julia and Julia-to-GAP Conversions. In all other situations, the conversions between GAP objects and corresponding Julia objects can be performed using gap_to_julia and julia_to_gap, see Explicit GAP-to-Julia and Julia-to-GAP Conversions, respectively.","category":"page"},{"location":"","page":"GAP.jl","title":"GAP.jl","text":"For convenience, also constructor methods are provided, for example Vector{Int64}(obj) can be used instead of GAP.gap_to_julia(Vector{Int64}, obj), where obj is a GAP list of integers; see Constructor Methods for GAP-to-Julia Conversions for a description of these methods. For Julia-to-GAP conversions, one can use for example GapObj(obj), where obj is a Julia object, see GapObj.","category":"page"},{"location":"#Automatic-GAP-to-Julia-and-Julia-to-GAP-Conversions","page":"GAP.jl","title":"Automatic GAP-to-Julia and Julia-to-GAP Conversions","text":"","category":"section"},{"location":"","page":"GAP.jl","title":"GAP.jl","text":"When one calls a GAP function with Julia objects as arguments, or a Julia function with GAP objects as arguments, the arguments are in general not automatically converted to GAP objects or Julia objects, respectively. The exceptions are as follows.","category":"page"},{"location":"","page":"GAP.jl","title":"GAP.jl","text":"GAP's immediate integers (in the range -2^60 to 2^60-1) are automatically converted to Julia's Int64 objects; Julia's Int64 objects are automatically converted to GAP's immediate integers if they fit, and to GAP's large integers otherwise.\nGAP's immediate finite field elements are automatically converted to Julia's GAP.FFE objects, and vice versa.\nGAP's true and false are automatically converted to Julia's true and false, and vice versa.","category":"page"},{"location":"#Explicit-GAP-to-Julia-and-Julia-to-GAP-Conversions","page":"GAP.jl","title":"Explicit GAP-to-Julia and Julia-to-GAP Conversions","text":"","category":"section"},{"location":"","page":"GAP.jl","title":"GAP.jl","text":"gap_to_julia\njulia_to_gap","category":"page"},{"location":"#GAP.gap_to_julia","page":"GAP.jl","title":"GAP.gap_to_julia","text":"gap_to_julia(type, x, recursion_dict=nothing; recursive::Bool=true)\n\nTry to convert the object x to a Julia object of type type. If x is a GAP.GapObj then the conversion rules are defined in the manual of the GAP package JuliaInterface. If x is another GAP.Obj (for example a Int64) then the result is defined in Julia by type.\n\nThe parameter recursion_dict is meant to preserve the identity of converted subobjects and should never be given by the user.\n\nFor GAP lists and records, it makes sense to convert also the subobjects recursively, or to keep the subobjects as they are; the behaviour is controlled by recursive, which can be true or false.\n\nExamples\n\njulia> GAP.gap_to_julia( GAP.evalstr( \"1/3\" ) )\n1//3\n\njulia> GAP.gap_to_julia( GAP.evalstr( \"\\\"abc\\\"\" ) )\n\"abc\"\n\njulia> val = GAP.evalstr( \"[ [ 1, 2 ], [ 3, 4 ] ]\" );\n\njulia> GAP.gap_to_julia( val )\n2-element Vector{Any}:\n Any[1, 2]\n Any[3, 4]\n\njulia> GAP.gap_to_julia( val, recursive = false )\n2-element Vector{Any}:\n GAP: [ 1, 2 ]\n GAP: [ 3, 4 ]\n\n\n\n\n\n\n","category":"function"},{"location":"#GAP.julia_to_gap","page":"GAP.jl","title":"GAP.julia_to_gap","text":"julia_to_gap(input, recursion_dict = IdDict(); recursive::Bool = false)\n\nConvert a julia object input to an appropriate GAP object. If recursive is set to true, recursive conversions on arrays, tuples, and dictionaries is performed.\n\nThe input recursion_dict should never be set by the user, it is meant to keep egality of input data, by converting egal data to identical objects in GAP.\n\nExamples\n\njulia> GAP.julia_to_gap(1//3)\nGAP: 1/3\n\njulia> GAP.julia_to_gap(\"abc\")\nGAP: \"abc\"\n\njulia> GAP.julia_to_gap([ [1, 2], [3, 4]])\nGAP: [ <Julia: [1, 2]>, <Julia: [3, 4]> ]\n\njulia> GAP.julia_to_gap([ [1, 2], [3, 4]], recursive = true)\nGAP: [ [ 1, 2 ], [ 3, 4 ] ]\n\n\n\n\n\n\n","category":"function"},{"location":"#Constructor-Methods-for-GAP-to-Julia-Conversions","page":"GAP.jl","title":"Constructor Methods for GAP-to-Julia Conversions","text":"","category":"section"},{"location":"","page":"GAP.jl","title":"GAP.jl","text":"(For Julia-to-GAP conversions, one can use GapObj as a constructor.)","category":"page"},{"location":"","page":"GAP.jl","title":"GAP.jl","text":"Int128\nBigInt\nRational\nFloat64\nbig\nChar\nCuchar\nString\nSymbol\nUnitRange\nStepRange\nTuple\nBitVector\nVector{T}\nMatrix{T}\nSet{T}\nDict{Symbol,T}","category":"page"},{"location":"#Core.Int128","page":"GAP.jl","title":"Core.Int128","text":"Int128 <: Signed\n\n128-bit signed integer type.\n\n\n\n\n\nInt128(obj::GapObj)\n\nReturn the Int128 converted from the GAP integer obj. (Note that small GAP integers are represented by Julia Int64 objects, in particular they are not GapObjs; their conversion is not handled by methods installed in GAP.jl.)\n\nExamples\n\njulia> val = GAP.evalstr(\"2^80\")\nGAP: 1208925819614629174706176\n\njulia> Int128(val)\n1208925819614629174706176\n\n\n\n\n\n\n","category":"type"},{"location":"#Base.GMP.BigInt","page":"GAP.jl","title":"Base.GMP.BigInt","text":"BigInt <: Signed\n\nArbitrary precision integer type.\n\n\n\n\n\n","category":"type"},{"location":"#Base.Rational","page":"GAP.jl","title":"Base.Rational","text":"Rational{T<:Integer} <: Real\n\nRational number type, with numerator and denominator of type T. Rationals are checked for overflow.\n\n\n\n\n\n","category":"type"},{"location":"#Core.Float64","page":"GAP.jl","title":"Core.Float64","text":"Float64 <: AbstractFloat\n\n64-bit floating point number type (IEEE 754 standard).\n\nBinary format: 1 sign, 11 exponent, 52 fraction bits.\n\n\n\n\n\n","category":"type"},{"location":"#Base.big","page":"GAP.jl","title":"Base.big","text":"big(x)\n\nConvert a number to a maximum precision representation (typically BigInt or BigFloat). See BigFloat for information about some pitfalls with floating-point numbers.\n\n\n\n\n\n","category":"function"},{"location":"#Core.Char","page":"GAP.jl","title":"Core.Char","text":"Char(c::Union{Number,AbstractChar})\n\nChar is a 32-bit AbstractChar type that is the default representation of characters in Julia. Char is the type used for character literals like 'x' and it is also the element type of String.\n\nIn order to losslessly represent arbitrary byte streams stored in a String, a Char value may store information that cannot be converted to a Unicode codepoint — converting such a Char to UInt32 will throw an error. The isvalid(c::Char) function can be used to query whether c represents a valid Unicode character.\n\n\n\n\n\n","category":"type"},{"location":"#Base.Cuchar","page":"GAP.jl","title":"Base.Cuchar","text":"Cuchar\n\nEquivalent to the native unsigned char c-type (UInt8).\n\n\n\n\n\n","category":"type"},{"location":"#Core.String","page":"GAP.jl","title":"Core.String","text":"String(v::AbstractVector{UInt8})\n\nCreate a new String object from a byte vector v containing UTF-8 encoded characters. If v is Vector{UInt8} it will be truncated to zero length and future modification of v cannot affect the contents of the resulting string. To avoid truncation of Vector{UInt8} data, use String(copy(v)); for other AbstractVector types, String(v) already makes a copy.\n\nWhen possible, the memory of v will be used without copying when the String object is created. This is guaranteed to be the case for byte vectors returned by take! on a writable IOBuffer and by calls to read(io, nb). This allows zero-copy conversion of I/O data to strings. In other cases, Vector{UInt8} data may be copied, but v is truncated anyway to guarantee consistent behavior.\n\n\n\n\n\nString(s::AbstractString)\n\nConvert a string to a contiguous byte array representation encoded as UTF-8 bytes. This representation is often appropriate for passing strings to C.\n\n\n\n\n\nString(obj::GapObj)\n\nReturn the Julia string converted from the GAP string obj. Note that GAP's String function can be applied to arbitrary GAP objects, similar to Julia's string function; this behaviour is not intended for this String constructor.\n\nExamples\n\njulia> val = GAP.evalstr(\"\\\"abc\\\"\")\nGAP: \"abc\"\n\njulia> String(val)\n\"abc\"\n\njulia> val = GAP.evalstr(\"[]\")\nGAP: [  ]\n\njulia> String(val)   # an empty GAP list is a string\n\"\"\n\n\n\n\n\n\n","category":"type"},{"location":"#Core.Symbol","page":"GAP.jl","title":"Core.Symbol","text":"Symbol\n\nThe type of object used to represent identifiers in parsed julia code (ASTs). Also often used as a name or label to identify an entity (e.g. as a dictionary key). Symbols can be entered using the : quote operator:\n\njulia> :name\n:name\n\njulia> typeof(:name)\nSymbol\n\njulia> x = 42\n42\n\njulia> eval(:x)\n42\n\nSymbols can also be constructed from strings or other values by calling the constructor Symbol(x...).\n\nSymbols are immutable and should be compared using ===. The implementation re-uses the same object for all Symbols with the same name, so comparison tends to be efficient (it can just compare pointers).\n\nUnlike strings, Symbols are \"atomic\" or \"scalar\" entities that do not support iteration over characters.\n\n\n\n\n\n","category":"type"},{"location":"#Base.UnitRange","page":"GAP.jl","title":"Base.UnitRange","text":"UnitRange{T<:Real}\n\nA range parameterized by a start and stop of type T, filled with elements spaced by 1 from start until stop is exceeded. The syntax a:b with a and b both Integers creates a UnitRange.\n\nExamples\n\njulia> collect(UnitRange(2.3, 5.2))\n3-element Vector{Float64}:\n 2.3\n 3.3\n 4.3\n\njulia> typeof(1:10)\nUnitRange{Int64}\n\n\n\n\n\nUnitRange(obj::GapObj)\n\nReturn the unit range converted from the GAP range obj, which has step width 1.\n\nExamples\n\njulia> val = GAP.evalstr(\"[ 1 .. 10 ]\")\nGAP: [ 1 .. 10 ]\n\njulia> UnitRange(val)\n1:10\n\njulia> UnitRange{Int32}(val)\n1:10\n\n\n\n\n\n\n","category":"type"},{"location":"#Base.StepRange","page":"GAP.jl","title":"Base.StepRange","text":"StepRange{T, S} <: OrdinalRange{T, S}\n\nRanges with elements of type T with spacing of type S. The step between each element is constant, and the range is defined in terms of a start and stop of type T and a step of type S. Neither T nor S should be floating point types. The syntax a:b:c with b > 1 and a, b, and c all integers creates a StepRange.\n\nExamples\n\njulia> collect(StepRange(1, Int8(2), 10))\n5-element Vector{Int64}:\n 1\n 3\n 5\n 7\n 9\n\njulia> typeof(StepRange(1, Int8(2), 10))\nStepRange{Int64, Int8}\n\njulia> typeof(1:3:6)\nStepRange{Int64, Int64}\n\n\n\n\n\nStepRange(obj::GapObj)\n\nReturn the step range converted from the GAP range obj, which may have arbitrary step width.\n\nExamples\n\njulia> val = GAP.evalstr(\"[ 1, 3 .. 11 ]\")\nGAP: [ 1, 3 .. 11 ]\n\njulia> StepRange(val)\n1:2:11\n\njulia> r = StepRange{Int8,Int8}(val)\n1:2:11\n\njulia> typeof(r)\nStepRange{Int8, Int8}\n\n\n\n\n\n\n","category":"type"},{"location":"#Core.Tuple","page":"GAP.jl","title":"Core.Tuple","text":"Tuple{Types...}\n\nTuples are an abstraction of the arguments of a function – without the function itself. The salient aspects of a function's arguments are their order and their types. Therefore a tuple type is similar to a parameterized immutable type where each parameter is the type of one field. Tuple types may have any number of parameters.\n\nTuple types are covariant in their parameters: Tuple{Int} is a subtype of Tuple{Any}. Therefore Tuple{Any} is considered an abstract type, and tuple types are only concrete if their parameters are. Tuples do not have field names; fields are only accessed by index.\n\nSee the manual section on Tuple Types.\n\n\n\n\n\nTuple{Types...}(obj::GapObj; recursive = true)\n\nReturn the tuple converted from the GAP list obj. The entries of the list are converted to the required types Types..., using gap_to_julia. If recursive is true then the entries of the list are converted recursively, otherwise non-recursively.\n\nExamples\n\njulia> val = GAP.evalstr(\"[ 1, 5 ]\")\nGAP: [ 1, 5 ]\n\njulia> Tuple{Int64,Int64}(val)\n(1, 5)\n\njulia> val = GAP.evalstr(\"[ [ 1 ], [ 2 ] ]\")\nGAP: [ [ 1 ], [ 2 ] ]\n\njulia> Tuple{Any,Any}(val)\n(Any[1], Any[2])\n\njulia> Tuple{GapObj,GapObj}(val, recursive = false)\n(GAP: [ 1 ], GAP: [ 2 ])\n\n\n\n\n\n\n","category":"type"},{"location":"#Base.BitVector","page":"GAP.jl","title":"Base.BitVector","text":"BitVector(nt::Tuple{Vararg{Bool}})\n\nConstruct a BitVector from a tuple of Bool.\n\nExamples\n\njulia> nt = (true, false, true, false)\n(true, false, true, false)\n\njulia> BitVector(nt)\n4-element BitVector:\n 1\n 0\n 1\n 0\n\n\n\n\n\nBitVector(obj::GapObj)\n\nReturn the bit vector converted from the GAP list of booleans obj.\n\nExamples\n\njulia> val = GAP.evalstr(\"[ true, false, true ]\")\nGAP: [ true, false, true ]\n\njulia> BitVector(val)\n3-element BitVector:\n 1\n 0\n 1\n\n\n\n\n\n\n","category":"type"},{"location":"#Base.Vector","page":"GAP.jl","title":"Base.Vector","text":"Vector{T} <: AbstractVector{T}\n\nOne-dimensional dense array with elements of type T, often used to represent a mathematical vector. Alias for Array{T,1}.\n\n\n\n\n\n","category":"type"},{"location":"#Base.Matrix","page":"GAP.jl","title":"Base.Matrix","text":"Matrix{T} <: AbstractMatrix{T}\n\nTwo-dimensional dense array with elements of type T, often used to represent a mathematical matrix. Alias for Array{T,2}.\n\n\n\n\n\n","category":"type"},{"location":"#Base.Set","page":"GAP.jl","title":"Base.Set","text":"Set([itr])\n\nConstruct a Set of the values generated by the given iterable object, or an empty set. Should be used instead of BitSet for sparse integer sets, or for sets of arbitrary objects.\n\n\n\n\n\nSet{T}(obj::GapObj; recursive = true)\n\nReturn the set converted from the GAP list or GAP collection obj. The elements of obj are converted to the required type T, using gap_to_julia. If recursive is true then the elements are converted recursively, otherwise non-recursively.\n\nThis constructor method is intended for situations where the result involves only native Julia objects such as integers and strings. Dealing with results containing GAP objects will be inefficient.\n\nExamples\n\njulia> Set{Int}(GAP.evalstr(\"[ 1, 2, 1 ]\"))\nSet{Int64} with 2 elements:\n  2\n  1\n\njulia> Set{Vector{Int}}(GAP.evalstr(\"[[1], [2], [1]]\"))\nSet{Vector{Int64}} with 2 elements:\n  [1]\n  [2]\n\njulia> Set{String}(GAP.evalstr(\"[\\\"a\\\", \\\"b\\\"]\"))\nSet{String} with 2 elements:\n  \"b\"\n  \"a\"\n\njulia> Set{Any}(GAP.evalstr(\"[[1], [2], [1]]\"))\nSet{Any} with 2 elements:\n  Any[1]\n  Any[2]\n\n\nIn the following examples, the order in which the Julia output is shown may vary.\n\nExamples\n\njulia> s = Set{Any}(GAP.evalstr(\"[[1], [2], [1]]\"), recursive = false);\n\njulia> s == Set{Any}([GAP.evalstr(\"[ 1 ]\"), GAP.evalstr(\"[ 2 ]\")])\ntrue\n\njulia> s = Set{Any}(GAP.evalstr(\"SymmetricGroup(2)\"), recursive = false);\n\njulia> s == Set{Any}([GAP.evalstr(\"()\"), GAP.evalstr(\"(1,2)\")])\ntrue\n\n\n\n\n\n\n","category":"type"},{"location":"#Base.Dict","page":"GAP.jl","title":"Base.Dict","text":"Dict([itr])\n\nDict{K,V}() constructs a hash table with keys of type K and values of type V. Keys are compared with isequal and hashed with hash.\n\nGiven a single iterable argument, constructs a Dict whose key-value pairs are taken from 2-tuples (key,value) generated by the argument.\n\nExamples\n\njulia> Dict([(\"A\", 1), (\"B\", 2)])\nDict{String, Int64} with 2 entries:\n  \"B\" => 2\n  \"A\" => 1\n\nAlternatively, a sequence of pair arguments may be passed.\n\njulia> Dict(\"A\"=>1, \"B\"=>2)\nDict{String, Int64} with 2 entries:\n  \"B\" => 2\n  \"A\" => 1\n\n\n\n\n\n","category":"type"},{"location":"#Convenience-adapters","page":"GAP.jl","title":"Convenience adapters","text":"","category":"section"},{"location":"","page":"GAP.jl","title":"GAP.jl","text":"This section describes how one can manipulate GAP objects from the Julia side, using Julia syntax features.","category":"page"},{"location":"","page":"GAP.jl","title":"GAP.jl","text":"Globals\ncall_gap_func\nevalstr\ngetindex\nsetindex!\ngetproperty\nsetproperty!\nhasproperty\nwrap_rng","category":"page"},{"location":"#GAP.Globals","page":"GAP.jl","title":"GAP.Globals","text":"Globals\n\nThis is a global object that gives access to all global variables of the current GAP session via getproperty and setproperty!.\n\nExamples\n\njulia> GAP.Globals.Size    # a global GAP function\nGAP: <Attribute \"Size\">\n\njulia> GAP.Globals.size    # there is no GAP variable with this name\nERROR: GAP variable size not bound\n[...]\n\njulia> hasproperty( GAP.Globals, :size )\nfalse\n\njulia> GAP.Globals.size = 17;\n\njulia> hasproperty( GAP.Globals, :size )\ntrue\n\njulia> GAP.Globals.size\n17\n\njulia> GAP.Globals.Julia   # Julia objects can be values of GAP variables\nMain\n\n\n\n\n\n\n","category":"constant"},{"location":"#GAP.call_gap_func","page":"GAP.jl","title":"GAP.call_gap_func","text":"call_gap_func(func::GapObj, args...; kwargs...)\n\nCall the GAP object func as a function, with arguments args... and global GAP options kwargs..., and return the result if there is one, and nothing otherwise.\n\nThere is no argument number checking here, all checks on the arguments are done by GAP itself.\n\nFor convenience, one can use the syntax func(args...; kwargs...).\n\nExamples\n\njulia> GAP.Globals.Factors( 12 )\nGAP: [ 2, 2, 3 ]\n\njulia> g = GAP.Globals.SylowSubgroup( GAP.Globals.SymmetricGroup( 6 ), 2 )\nGAP: Group([ (1,2), (3,4), (1,3)(2,4), (5,6) ])\n\njulia> GAP.Globals.StructureDescription( g )\nGAP: \"C2 x D8\"\n\njulia> g = GAP.Globals.SylowSubgroup( GAP.Globals.SymmetricGroup( 6 ), 2 );\n\njulia> GAP.Globals.StructureDescription( g, short = true )\nGAP: \"2xD8\"\n\n\n\n\n\n\n","category":"function"},{"location":"#GAP.evalstr","page":"GAP.jl","title":"GAP.evalstr","text":"evalstr(cmd::String)\n\nLet GAP execute the command(s) given by cmd; if an error occurs then report this error, otherwise if the last command has a result then return it, otherwise return nothing.\n\nExamples\n\njulia> GAP.evalstr( \"1+2\" )\n3\n\njulia> GAP.evalstr( \"x:= []\" )\nGAP: [  ]\n\njulia> GAP.evalstr( \"y:= 2; Add( x, 1 )\" )\n\njulia> GAP.evalstr( \"x\" )\nGAP: [ 1 ]\n\n\n\n\n\n\n","category":"function"},{"location":"#Base.getindex","page":"GAP.jl","title":"Base.getindex","text":"getindex(collection, key...)\n\nRetrieve the value(s) stored at the given key or index within a collection. The syntax a[i,j,...] is converted by the compiler to getindex(a, i, j, ...).\n\nExamples\n\njulia> A = Dict(\"a\" => 1, \"b\" => 2)\nDict{String, Int64} with 2 entries:\n  \"b\" => 2\n  \"a\" => 1\n\njulia> getindex(A, \"a\")\n1\n\n\n\n\n\n","category":"function"},{"location":"#Base.setindex!","page":"GAP.jl","title":"Base.setindex!","text":"setindex!(collection, value, key...)\n\nStore the given value at the given key or index within a collection. The syntax a[i,j,...] = x is converted by the compiler to (setindex!(a, x, i, j, ...); x).\n\n\n\n\n\n","category":"function"},{"location":"#Base.getproperty","page":"GAP.jl","title":"Base.getproperty","text":"getproperty(value, name::Symbol)\n\nThe syntax a.b calls getproperty(a, :b).\n\nExamples\n\njulia> struct MyType\n           x\n       end\n\njulia> function Base.getproperty(obj::MyType, sym::Symbol)\n           if sym === :special\n               return obj.x + 1\n           else # fallback to getfield\n               return getfield(obj, sym)\n           end\n       end\n\njulia> obj = MyType(1);\n\njulia> obj.special\n2\n\njulia> obj.x\n1\n\nSee also propertynames and setproperty!.\n\n\n\n\n\n","category":"function"},{"location":"#Base.setproperty!","page":"GAP.jl","title":"Base.setproperty!","text":"setproperty!(value, name::Symbol, x)\n\nThe syntax a.b = c calls setproperty!(a, :b, c).\n\nSee also propertynames and getproperty.\n\n\n\n\n\n","category":"function"},{"location":"#Base.hasproperty","page":"GAP.jl","title":"Base.hasproperty","text":"hasproperty(x, s::Symbol)\n\nReturn a boolean indicating whether the object x has s as one of its own properties.\n\ncompat: Julia 1.2\nThis function requires at least Julia 1.2.\n\n\n\n\n\nhasproperty(x::GapObj, f::Symbol)\nhasproperty(x::GapObj, f::Union{AbstractString,Int64})\n\nReturn true if the GAP record x has a component that is described by f, and false otherwise.\n\nExamples\n\njulia> r = GAP.evalstr( \"rec( a:= 1 )\" )\nGAP: rec( a := 1 )\n\njulia> hasproperty( r, :a )\ntrue\n\njulia> hasproperty( r, :b )\nfalse\n\njulia> r.b = 2\n2\n\njulia> hasproperty( r, :b )\ntrue\n\njulia> r\nGAP: rec( a := 1, b := 2 )\n\n\n\n\n\n\n","category":"function"},{"location":"#GAP.wrap_rng","page":"GAP.jl","title":"GAP.wrap_rng","text":"wrap_rng(rng::Random.AbstractRNG)\n\nReturn a GAP object in the filter IsRandomSource that uses rng in calls to GAP's Random function. The idea is that GAP's Random methods for high level objects will just hand over the given random source to subfunctions until Random gets called for a list or the bounds of a range, and then Base.rand gets called with rng.\n\nExamples\n\njulia> rng1 = Random.default_rng();\n\njulia> rng2 = copy(rng1);\n\njulia> rng1 == rng2\ntrue\n\njulia> rng1 === rng2\nfalse\n\njulia> gap_rng1 = GAP.wrap_rng(rng1)\nGAP: <RandomSource in IsRandomSourceJulia>\n\njulia> gap_rng2 = GAP.wrap_rng(rng2)\nGAP: <RandomSource in IsRandomSourceJulia>\n\njulia> res1 = GAP.Globals.Random(gap_rng1, 1, 10);\n\njulia> rng1 == rng2   # the two rngs have diverged\nfalse\n\njulia> res1 == GAP.Globals.Random(gap_rng2, GAP.GapObj(1:10))\ntrue\n\njulia> rng1 == rng2   # now the two rngs are again in sync\ntrue\n\njulia> g = GAP.Globals.SymmetricGroup(10);\n\njulia> p = GAP.Globals.Random(gap_rng1, g);\n\njulia> p in g\ntrue\n\njulia> GAP.Globals.Random(gap_rng1, GAP.Globals.GF(2)^10)\nGAP: <a GF2 vector of length 10>\n\n\n\n\n\n\n","category":"function"},{"location":"","page":"GAP.jl","title":"GAP.jl","text":"For the following Julia functions, methods are provided that deal with the case that the arguments are GAP objects; they delegate to the corresponding GAP operations.","category":"page"},{"location":"","page":"GAP.jl","title":"GAP.jl","text":"Julia GAP\nlength Length\nin \\in\nzero ZERO\none ONE\n- (unary) AINV\n+ SUM\n- (binary) DIFF\n* PROD\n/ QUO\n\\ LQUO\n^ POW\nmod MOD\n< LT\n== EQ","category":"page"},{"location":"","page":"GAP.jl","title":"GAP.jl","text":"julia> l = GAP.julia_to_gap( [ 1, 3, 7, 15 ] )\nGAP: [ 1, 3, 7, 15 ]\n\njulia> m = GAP.julia_to_gap( [ 1 2; 3 4 ] )\nGAP: [ [ 1, 2 ], [ 3, 4 ] ]\n\njulia> length( l )\n4\n\njulia> length( m )  # different from Julia's behaviour\n2\n\njulia> 1 in l\ntrue\n\njulia> 2 in l\nfalse\n\njulia> zero( l )\nGAP: [ 0, 0, 0, 0 ]\n\njulia> one( m )\nGAP: [ [ 1, 0 ], [ 0, 1 ] ]\n\njulia> - l\nGAP: [ -1, -3, -7, -15 ]\n\njulia> l + 1\nGAP: [ 2, 4, 8, 16 ]\n\njulia> l + l\nGAP: [ 2, 6, 14, 30 ]\n\njulia> m + m\nGAP: [ [ 2, 4 ], [ 6, 8 ] ]\n\njulia> 1 - m\nGAP: [ [ 0, -1 ], [ -2, -3 ] ]\n\njulia> l * l\n284\n\njulia> l * m\nGAP: [ 10, 14 ]\n\njulia> m * m\nGAP: [ [ 7, 10 ], [ 15, 22 ] ]\n\njulia> 1 / m\nGAP: [ [ -2, 1 ], [ 3/2, -1/2 ] ]\n\njulia> m / 2\nGAP: [ [ 1/2, 1 ], [ 3/2, 2 ] ]\n\njulia> 2 \\ m\nGAP: [ [ 1/2, 1 ], [ 3/2, 2 ] ]\n\njulia> m ^ 2\nGAP: [ [ 7, 10 ], [ 15, 22 ] ]\n\njulia> m ^ -1\nGAP: [ [ -2, 1 ], [ 3/2, -1/2 ] ]\n\njulia> mod( l, 3 )\nGAP: [ 1, 0, 1, 0 ]\n\njulia> m < 2 * m\ntrue\n\njulia> m^2 - 5 * m == 2 * one( m )\ntrue\n","category":"page"},{"location":"#Access-to-the-GAP-help-system","page":"GAP.jl","title":"Access to the GAP help system","text":"","category":"section"},{"location":"","page":"GAP.jl","title":"GAP.jl","text":"show_gap_help","category":"page"},{"location":"#GAP.show_gap_help","page":"GAP.jl","title":"GAP.show_gap_help","text":"show_gap_help(topic::String, onlyexact::Bool = false)\n\nPrint the information from the GAP help system about topic to the screen. If onlyexact is true then only exact matches are shown, otherwise all matches. For example, GAP.show_gap_help(\"Size\") shows also documentation for SizeScreen and SizesPerfectGroups, whereas GAP.show_gap_help(\"Size\", true) shows only documentation for Size.\n\nFor the variant showing all matches, one can also enter ?GAP.Globals.Size at the Julia prompt instead of calling show_gap_help.\n\nExamples\n\njulia> GAP.show_gap_help( \"Size\" )\n[...]  # more than 50 entries from GAP manuals\n\nhelp?> GAP.Globals.Size\n[...]  # the same\n\njulia> GAP.show_gap_help( \"Size\", true )\n[...]  # about 15 entries from GAP manuals\n\n\n\n\n\n\n","category":"function"},{"location":"#Managing-GAP-packages","page":"GAP.jl","title":"Managing GAP packages","text":"","category":"section"},{"location":"","page":"GAP.jl","title":"GAP.jl","text":"The following functions allow one to load/install/update/remove GAP packages.","category":"page"},{"location":"","page":"GAP.jl","title":"GAP.jl","text":"GAP.Packages.load\nGAP.Packages.install\nGAP.Packages.update\nGAP.Packages.remove","category":"page"},{"location":"#GAP.Packages.load","page":"GAP.jl","title":"GAP.Packages.load","text":"load(spec::String, version::String = \"\"; install = false)\n\nTry to load the newest installed version of the GAP package with name spec. Return true if this is successful, and false otherwise.\n\nThe function calls GAP's LoadPackage function; the package banner is not printed.\n\nIf install is set to true and the required GAP package is not yet installed then install is called first, in order to install the newest released version of the package.\n\n\n\n\n\n","category":"function"},{"location":"#GAP.Packages.install","page":"GAP.jl","title":"GAP.Packages.install","text":"install(spec::String; interactive::Bool = true, quiet::Bool = false)\n\nDownload and install the newest released version of the GAP package given by spec in the pkg subdirectory of GAP's build directory (variable GAP.GAPROOT). Return true if the installation is successful or if the package was already installed, and false otherwise.\n\nspec can be either the name of a package or the URL of an archive or repository containing a package, or the URL of a PackageInfo.g file.\n\nThe function uses the function InstallPackage from GAP's package PackageManager. The info messages shown by  this function can be suppressed by entering true as the value of quiet.\n\n\n\n\n\n","category":"function"},{"location":"#GAP.Packages.update","page":"GAP.jl","title":"GAP.Packages.update","text":"update(spec::String; quiet::Bool = false)\n\nUpdate the GAP package given by spec that is installed in the pkg subdirectory of GAP's build directory (variable GAP.GAPROOT), to the latest version. Return true if a newer version was installed successfully, or if no newer version is available, and false otherwise.\n\nspec can be either the name of a package or the URL of an archive or repository containing a package, or the URL of a PackageInfo.g file.\n\nThe function uses the function UpdatePackage from GAP's package PackageManager. The info messages shown by  this function can be suppressed by entering true as the value of quiet.\n\n\n\n\n\n","category":"function"},{"location":"#GAP.Packages.remove","page":"GAP.jl","title":"GAP.Packages.remove","text":"remove(spec::String; quiet::Bool = false)\n\nRemove the GAP package with name spec that is installed in the pkg subdirectory of GAP's build directory (variable GAP.GAPROOT). Return true if the removal was successful, and false otherwise.\n\nThe function uses the function RemovePackage from GAP's package PackageManager. The info messages shown by  this function can be suppressed by entering true as the value of quiet.\n\n\n\n\n\n","category":"function"},{"location":"#Other","page":"GAP.jl","title":"Other","text":"","category":"section"},{"location":"","page":"GAP.jl","title":"GAP.jl","text":"GAP.prompt\nGAP.create_gap_sh","category":"page"},{"location":"#GAP.prompt","page":"GAP.jl","title":"GAP.prompt","text":"prompt()\n\nStart a GAP prompt where you can enter GAP commands as in a regular GAP session. This prompt can be left as any GAP prompt by either entering quit; or pressing ctrl-D, which returns to the Julia prompt.\n\nThis GAP prompt allows to quickly switch between writing Julia and GAP code in a session where all data is shared.\n\n\n\n\n\n","category":"function"},{"location":"#GAP.create_gap_sh","page":"GAP.jl","title":"GAP.create_gap_sh","text":"create_gap_sh(dstdir::String)\n\nGiven a directory path, create three files in that directory:\n\na shell script named gap.sh which acts like the gap.sh shipped with a regular GAP installation, but which behind the scenes launches GAP via Julia.\ntwo TOML files, Manifest.toml and Project.toml, which are required by gap.sh to function (they record the precise versions of GAP.jl and other Julia packages involved)\n\n\n\n\n\n","category":"function"},{"location":"#Index","page":"GAP.jl","title":"Index","text":"","category":"section"},{"location":"","page":"GAP.jl","title":"GAP.jl","text":"","category":"page"}]
}
